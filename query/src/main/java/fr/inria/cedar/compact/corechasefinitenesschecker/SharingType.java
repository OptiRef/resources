package fr.inria.cedar.compact.corechasefinitenesschecker;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.apache.commons.lang3.tuple.ImmutablePair;
import org.apache.commons.lang3.tuple.Pair;

import fr.lirmm.graphik.graal.api.core.Atom;
import fr.lirmm.graphik.graal.api.core.ConstantGenerator;
import fr.lirmm.graphik.graal.api.core.Predicate;
import fr.lirmm.graphik.graal.api.core.Term;
import fr.lirmm.graphik.graal.api.core.Variable;
import fr.lirmm.graphik.graal.api.core.VariableGenerator;
import fr.lirmm.graphik.graal.api.factory.AtomFactory;
import fr.lirmm.graphik.graal.core.DefaultConstantGenerator;
import fr.lirmm.graphik.graal.core.DefaultVariableGenerator;
import fr.lirmm.graphik.graal.core.factory.DefaultAtomFactory;

/**
 * 
 * @author Michael Thomazo (Inria)
 * Representation of a sharing type.
 */
public class SharingType{

	//TODO: add support for constants
	// p and partition represent the classical type
	final Predicate p;
	final Set<Set<Integer>> partition;
	//sharedPositions contains the shared positions, which is the difference between classical type and sharing type 
	final Set<Integer> sharedPositions;

	public SharingType(final Predicate p, final Set<Set<Integer>> partition, final Set<Integer> sharedPositions){
		this.p = p;
		this.partition = partition;
		this.sharedPositions = sharedPositions;
	}


	public SharingType(final Atom a,Set<Variable> frontier){
		this.p = a.getPredicate();
		final Set<Integer> sharedPositions = new HashSet<Integer>();
		final Set<Set<Integer>> partition = new HashSet<Set<Integer>>();
		final Map<Term,Set<Integer>> term2positions = new HashMap<Term,Set<Integer>>(); 
		int pos = -1;
		for (Term t:a.getTerms()){
			pos++;
			if (frontier.contains(t)){
				sharedPositions.add(pos);
			}
			if (!term2positions.containsKey(t)){
				term2positions.put(t, new HashSet<Integer>());
			}
			term2positions.get(t).add(pos);
		}
		partition.addAll(term2positions.values());
		this.partition = partition;
		this.sharedPositions = sharedPositions;
	}

	/**
	 * 
	 * @param i a position 
	 * @param j another position
	 * @return true if and only if both positions are in the same partition (i.e., terms at both positions are equal)
	 */
	public boolean samePartition(final Integer i,final Integer j){
		for (final Set<Integer> partitionElement:partition){
			if (partitionElement.contains(i)){
				return partitionElement.contains(j);
			}
		}
		throw new IllegalStateException("i has not been found in the partition");
	}

	
	/**
	 * 
	 * @param freezedpositions: a set of positions of this
	 * @return an atom of type this (without the sharing part) and that has constants exactly at freezed positions
	 */
	public Pair<Atom,Map<Integer,Term>> createAtom(final Collection<Integer> freezedpositions){
		final AtomFactory af = DefaultAtomFactory.instance();
		final Map<Integer,Term> pos2Term = new HashMap<Integer,Term>();
		final VariableGenerator vg = new DefaultVariableGenerator("x");
		final ConstantGenerator cg = new DefaultConstantGenerator("c");
		for (Set<Integer> partitionClass:this.partition){
			boolean isFreezed = false;
			for (Integer i:freezedpositions){
				if (partitionClass.contains(i))
					isFreezed = true;
			}
			final Term t;
			if (isFreezed){
				t = cg.getFreshSymbol();
			}
			else{
				t = vg.getFreshSymbol();
			}
			for (Integer i:partitionClass){
				pos2Term.put(i, t);
			}
		}
		final List<Term> arguments = new ArrayList<Term>();
		for (int i=0;i<this.p.getArity();i++){
			arguments.add(pos2Term.get(i));
		}
		return new ImmutablePair<Atom,Map<Integer,Term>>(af.create(this.p, arguments),pos2Term);
	}

	/**
	 * 
	 * @param pos2Term: a mapping from the position of another sharing type (the parent) to terms
	 * @param pos2pos: a mapping from the positions of this sharing type to another sharing type
	 * @return an atom that has the same term as the atom generated by the above function exactly when both positions are linkedthrough pos2pos
	 */
	public Atom createAtom(final Map<Integer,Term> pos2Term, 
			final Map<Integer,Integer> pos2pos){
		final AtomFactory af = DefaultAtomFactory.instance();
		final VariableGenerator vg = new DefaultVariableGenerator("y");
		final Map<Integer,Term> novelPos2Term = new HashMap<Integer,Term>();
		for (Set<Integer> partitionClass:this.partition){
			boolean isFreezed = false;
			Term t = null;
			for (Integer i:partitionClass){
				if (pos2pos.containsKey(i)){
					t = pos2Term.get(pos2pos.get(i));
					isFreezed = true;
					break;
				}
			}
			if (!isFreezed){
				t = vg.getFreshSymbol();
			}
			for (Integer i:partitionClass){
				novelPos2Term.put(i, t);
			}
		}
		final List<Term> arguments = new ArrayList<Term>();
		for (int i=0;i<this.p.getArity();i++){
			arguments.add(novelPos2Term.get(i));
		}
		return af.create(this.p, arguments);
	}

	
	

	@Override 
	public boolean equals(Object o){
		if (!(o instanceof SharingType))
			return false;
		SharingType ost = (SharingType) o;
		if (!p.equals(ost.p))
			return false;
		if (!this.partition.equals(ost.partition))
			return false;
		if (!this.sharedPositions.equals(ost.sharedPositions))
			return false;
		return true;
	}

	//TODO:provide a better hash function? 
	//hash and equals should be implemented, as used in HashSets
	@Override 
	public int hashCode(){
		return p.hashCode() + partition.hashCode() + sharedPositions.hashCode();
	}

	@Override
	public String toString(){
		return p.toString() + "\npartition" + partition.toString() + "\nsharedPositions" + sharedPositions.toString();
	}
}
