package fr.inria.cedar.compact.corechasefinitenesschecker;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;

import fr.lirmm.graphik.graal.api.core.Atom;
import fr.lirmm.graphik.graal.api.core.AtomSet;
import fr.lirmm.graphik.graal.api.core.Rule;
import fr.lirmm.graphik.graal.api.core.RuleSet;
import fr.lirmm.graphik.graal.api.core.Substitution;
import fr.lirmm.graphik.graal.api.core.Variable;
import fr.lirmm.graphik.graal.core.DefaultAtom;
import fr.lirmm.graphik.graal.core.TreeMapSubstitution;
import fr.lirmm.graphik.graal.core.ruleset.IndexedByBodyPredicatesRuleSet;
import fr.lirmm.graphik.util.stream.CloseableIterator;

/**
 * 
 * @author Michael Thomazo (Inria)
 * Generates a set of atomic instances, such that the core chase wrt rules on one of these instances does not terminate if and only if
 * there exists an instance such that the core chase wrt rules does not terminate. 
 *
 */

/*
 * TODO: check this sharing type generator is generating enough starting types. Two optimizations are done:
 *  -- starting  sharing type should be a specialization of the head of an existential rule, with all terms marked as generated 
 *  -- a specialization of a head of an existential rule is useful to be considered only if the specialization can be "exploited by a rule application",
 *  i.e. for all rule, we add only the least specialized rule heads that allow for a rule application (and the original rule head)
 */

public class SharingTypeGenerator {


	final RuleSet rules;
	final IndexedByBodyPredicatesRuleSet indexedByBodyPredicateRules;

	public SharingTypeGenerator(RuleSet rules){
		this.rules = rules;
		this.indexedByBodyPredicateRules = new IndexedByBodyPredicatesRuleSet(rules);
	}

	/**
	 * 
	 * @param at: an atom
	 * @param fr: a set of variables on which atom can be specialized
	 * @param rule: a linear rule of same body predicate as atom
	 * @return the minimal specialization of atom on which rule is applicable
	 * 
	 *FIXME: fr is not used so far. Not too problematic, as this would generate too many starting sharing type, but not exlude a required one
	 */

	private Atom generateFrontierSpecializedAtom(Atom at,Set<Variable> fr, Rule rule){
		Atom ruleBody = rule.getBody().iterator().next();
		if (!ruleBody.getPredicate().equals(at.getPredicate())){
			return null;
		}
		int arity = ruleBody.getPredicate().getArity();
		Atom currentAtom = new DefaultAtom(at);
		boolean hasChanged = true;
		while (hasChanged){
			hasChanged = false;
			for (int i=0;i<arity;i++){
				for (int j=i+1;j<arity;j++){
					if (ruleBody.getTerm(i).equals(ruleBody.getTerm(j))){
						if (!currentAtom.getTerm(i).equals(currentAtom.getTerm(j))){
							Substitution pi = new TreeMapSubstitution();
							pi.put((Variable)currentAtom.getTerm(j),currentAtom.getTerm(i));
							currentAtom = pi.createImageOf(currentAtom);
						}
					}
				}
			}
		}
		return currentAtom;
	}

	
	/**
	 * 
	 * @param at: an atom
	 * @param fr: a set of variables on which the atom can be specialized
	 * @return specializations of atom that can should used a starting fact
	 */
	private Set<Atom> generateFrontierSpecializedAtoms(Atom at,Set<Variable> fr){
		Set<Atom> result = new HashSet<Atom>();
		for (Rule rule:this.indexedByBodyPredicateRules.getRulesByBodyPredicate(at.getPredicate())){
			Atom toAdd = generateFrontierSpecializedAtom(at,fr,rule);
			if (toAdd != null)
				result.add(toAdd);
		}

		return result;
	}
	/**
	 * 
	 * @param at: an atom generating an existential variable
	 * @param fr: the terms of the atoms that are shared with the previous
	 * @return
	 */
	private List<SharingType> generateStartingSharingType(Atom at, Set<Variable> fr){
		List<SharingType> result = new ArrayList<SharingType>();
		for (Atom specializedAtom:generateFrontierSpecializedAtoms(at, fr)){
			result.add(new SharingType(specializedAtom,new HashSet<Variable>()));
		}
		result.add(new SharingType(at,new HashSet<Variable>()));
		return result;
	}

	/**
	 * 
	 * @param rule
	 * @return generates the sharing types of bags generated by rule
	 * that may appear on an arbitrary long path in a derivation tree
	 */
	private List<SharingType> generateStartingSharingType(Rule rule){
		List<SharingType> result = new ArrayList<SharingType>();
		AtomSet head = rule.getHead();
		Set<Variable> fr = rule.getFrontier();
		CloseableIterator<Atom> it = head.iterator();
		try{
			while (it.hasNext()){
				Atom at = it.next();
				result.addAll(generateStartingSharingType(at,fr));
			}
		}
		catch (Exception e){
			e.printStackTrace();
		}
		return result;

	}

	/**
	 * 
	 * @param st: an initially empty set of sharing types
	 * generateStartingSharingType fills st with the sharing types that
	 *  may appear on an arbitrary long path in a derivation tree
	 */
	public void generateStartingSharingType(Set<SharingType> st){
		Iterator<Rule> it = rules.iterator();
		while (it.hasNext()){
			Rule rule = it.next();
			if (!rule.getExistentials().isEmpty())
				st.addAll(generateStartingSharingType(rule));
		}
	}



}
